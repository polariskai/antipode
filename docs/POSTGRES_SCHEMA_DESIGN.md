# PostgreSQL Schema Design for Adversarial AML System

## Overview

This document describes the PostgreSQL schema for storing synthetic AML scenarios, entities, accounts, transactions, and ground truth labels generated by the adversarial agent system.

## Design Principles

1. **Ground Truth Separation**: Visible data and labels stored in separate tables
2. **Normalized Schema**: Minimize redundancy, maximize query flexibility
3. **Indexing Strategy**: Optimize for common query patterns (entity lookup, transaction analysis, pattern detection)
4. **JSONB for Flexibility**: Use JSONB for semi-structured metadata and ground truth
5. **Audit Trail**: Track when scenarios are created and modified
6. **Partitioning Ready**: Design supports future partitioning by date or scenario type

## Schema Overview

```
┌─────────────────┐
│   scenarios     │ (Master table)
└────────┬────────┘
         │
         ├──────────────────────────────┐
         │                              │
         ▼                              ▼
┌────────────────┐            ┌──────────────────┐
│    entities    │            │ scenario_metadata│
└────────┬───────┘            └──────────────────┘
         │
         ├──────────────┬─────────────┐
         │              │             │
         ▼              ▼             ▼
┌────────────┐  ┌──────────────┐  ┌─────────────┐
│  accounts  │  │relationships │  │entity_ground│
└─────┬──────┘  └──────────────┘  │   _truth    │
      │                            └─────────────┘
      │
      ├─────────────────┬──────────────────┐
      │                 │                  │
      ▼                 ▼                  ▼
┌──────────────┐  ┌────────────┐  ┌──────────────────┐
│ transactions │  │ txn_ground │  │account_ground    │
│              │  │  _truth    │  │  _truth          │
└──────────────┘  └────────────┘  └──────────────────┘
```

## Table Definitions

### 1. scenarios
**Purpose**: Master table for scenario metadata

```sql
CREATE TABLE scenarios (
    scenario_id VARCHAR(100) PRIMARY KEY,
    typology VARCHAR(50) NOT NULL,
    total_amount DECIMAL(18, 2),
    complexity INTEGER CHECK (complexity BETWEEN 1 AND 10),
    apply_evasion BOOLEAN DEFAULT TRUE,
    scenario_description TEXT,  -- Custom user description
    num_entities INTEGER,
    num_accounts INTEGER,
    num_transactions INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'active',  -- active, completed, archived

    -- Indexes
    INDEX idx_typology (typology),
    INDEX idx_created_at (created_at),
    INDEX idx_status (status)
);

COMMENT ON TABLE scenarios IS 'Master table for AML money laundering scenarios';
COMMENT ON COLUMN scenarios.scenario_description IS 'User-provided custom scenario description';
COMMENT ON COLUMN scenarios.typology IS 'Money laundering typology: structuring, layering, crypto_mixing, etc.';
```

### 2. scenario_metadata
**Purpose**: Store scenario plan and ground truth

```sql
CREATE TABLE scenario_metadata (
    id SERIAL PRIMARY KEY,
    scenario_id VARCHAR(100) REFERENCES scenarios(scenario_id) ON DELETE CASCADE,
    plan_steps JSONB,  -- Array of steps from ScenarioPlanner
    evasion_techniques JSONB,  -- Array of evasion techniques
    validation_results JSONB,  -- Validation output
    memory_stats JSONB,  -- Entity reuse statistics
    metadata JSONB,  -- Additional flexible metadata

    UNIQUE (scenario_id)
);

CREATE INDEX idx_scenario_metadata_scenario ON scenario_metadata(scenario_id);
COMMENT ON TABLE scenario_metadata IS 'Scenario planning details and ground truth';
```

### 3. entities
**Purpose**: Store entities (individuals, companies) - VISIBLE DATA ONLY

```sql
CREATE TABLE entities (
    entity_id VARCHAR(100) PRIMARY KEY,
    scenario_id VARCHAR(100) REFERENCES scenarios(scenario_id) ON DELETE CASCADE,
    entity_type VARCHAR(50) NOT NULL,  -- individual, company, LLC, trust, partnership, foundation
    entity_subtype VARCHAR(50),  -- shell_company, nominee, etc.
    name VARCHAR(255) NOT NULL,
    country VARCHAR(3),  -- ISO 3166-1 alpha-3
    created_at TIMESTAMP,

    -- Indexes
    INDEX idx_entities_scenario (scenario_id),
    INDEX idx_entities_type (entity_type),
    INDEX idx_entities_country (country),
    INDEX idx_entities_name (name)
);

COMMENT ON TABLE entities IS 'Entity data - VISIBLE ONLY (no ground truth)';
COMMENT ON COLUMN entities.entity_type IS 'Realistic entity types: individual, company, LLC, trust, partnership, foundation';
```

### 4. entity_ground_truth
**Purpose**: Store entity ground truth labels (SEPARATED)

```sql
CREATE TABLE entity_ground_truth (
    id SERIAL PRIMARY KEY,
    entity_id VARCHAR(100) REFERENCES entities(entity_id) ON DELETE CASCADE,
    is_shell BOOLEAN DEFAULT FALSE,
    is_nominee BOOLEAN DEFAULT FALSE,
    is_suspicious BOOLEAN DEFAULT TRUE,
    risk_score INTEGER CHECK (risk_score BETWEEN 1 AND 10),
    suspicious_indicators JSONB,  -- Array of indicators
    role_in_scenario VARCHAR(100),  -- Role like "mule", "shell_company", "intermediary"
    scenarios_used TEXT[],  -- Array of scenario IDs where this entity was reused

    UNIQUE (entity_id)
);

CREATE INDEX idx_entity_gt_entity ON entity_ground_truth(entity_id);
CREATE INDEX idx_entity_gt_suspicious ON entity_ground_truth(is_suspicious);
CREATE INDEX idx_entity_gt_role ON entity_ground_truth(role_in_scenario);

COMMENT ON TABLE entity_ground_truth IS 'Entity ground truth labels - SEPARATED from visible data';
```

### 5. accounts
**Purpose**: Bank accounts linked to entities - VISIBLE DATA

```sql
CREATE TABLE accounts (
    account_id VARCHAR(100) PRIMARY KEY,
    entity_id VARCHAR(100) REFERENCES entities(entity_id) ON DELETE CASCADE,
    scenario_id VARCHAR(100) REFERENCES scenarios(scenario_id) ON DELETE CASCADE,
    account_type VARCHAR(50),  -- checking, savings, business, offshore
    bank VARCHAR(255),
    country VARCHAR(3),
    currency VARCHAR(3),  -- USD, EUR, GBP, etc.
    opened_date DATE,

    -- Indexes
    INDEX idx_accounts_entity (entity_id),
    INDEX idx_accounts_scenario (scenario_id),
    INDEX idx_accounts_bank (bank),
    INDEX idx_accounts_country (country)
);

COMMENT ON TABLE accounts IS 'Bank accounts - VISIBLE DATA ONLY';
```

### 6. account_ground_truth
**Purpose**: Account ground truth labels

```sql
CREATE TABLE account_ground_truth (
    id SERIAL PRIMARY KEY,
    account_id VARCHAR(100) REFERENCES accounts(account_id) ON DELETE CASCADE,
    is_suspicious BOOLEAN DEFAULT TRUE,
    account_purpose VARCHAR(100),  -- e.g., "layering", "integration", "structuring"
    metadata JSONB,

    UNIQUE (account_id)
);

CREATE INDEX idx_account_gt_account ON account_ground_truth(account_id);
CREATE INDEX idx_account_gt_suspicious ON account_ground_truth(is_suspicious);
```

### 7. transactions
**Purpose**: Financial transactions - VISIBLE DATA

```sql
CREATE TABLE transactions (
    transaction_id VARCHAR(100) PRIMARY KEY,
    scenario_id VARCHAR(100) REFERENCES scenarios(scenario_id) ON DELETE CASCADE,
    from_account_id VARCHAR(100) REFERENCES accounts(account_id),
    to_account_id VARCHAR(100) REFERENCES accounts(account_id),
    amount DECIMAL(18, 2) NOT NULL,
    currency VARCHAR(3) DEFAULT 'USD',
    timestamp TIMESTAMP NOT NULL,
    description TEXT,
    transaction_type VARCHAR(50),  -- wire, ach, cash, crypto, etc.

    -- Indexes
    INDEX idx_txn_scenario (scenario_id),
    INDEX idx_txn_from_account (from_account_id),
    INDEX idx_txn_to_account (to_account_id),
    INDEX idx_txn_timestamp (timestamp),
    INDEX idx_txn_amount (amount),
    INDEX idx_txn_type (transaction_type)
);

COMMENT ON TABLE transactions IS 'Financial transactions - VISIBLE DATA ONLY';
```

### 8. transaction_ground_truth
**Purpose**: Transaction ground truth labels

```sql
CREATE TABLE transaction_ground_truth (
    id SERIAL PRIMARY KEY,
    transaction_id VARCHAR(100) REFERENCES transactions(transaction_id) ON DELETE CASCADE,
    is_suspicious BOOLEAN DEFAULT TRUE,
    suspicion_reason TEXT,
    typology VARCHAR(50),  -- structuring, layering, etc.
    step_number INTEGER,
    evasion_techniques JSONB,  -- Array of techniques used
    metadata JSONB,

    UNIQUE (transaction_id)
);

CREATE INDEX idx_txn_gt_transaction ON transaction_ground_truth(transaction_id);
CREATE INDEX idx_txn_gt_suspicious ON transaction_ground_truth(is_suspicious);
CREATE INDEX idx_txn_gt_typology ON transaction_ground_truth(typology);
```

### 9. relationships
**Purpose**: Relationships between entities

```sql
CREATE TABLE relationships (
    id SERIAL PRIMARY KEY,
    scenario_id VARCHAR(100) REFERENCES scenarios(scenario_id) ON DELETE CASCADE,
    from_entity_id VARCHAR(100) REFERENCES entities(entity_id) ON DELETE CASCADE,
    to_entity_id VARCHAR(100) REFERENCES entities(entity_id) ON DELETE CASCADE,
    relationship_type VARCHAR(50) NOT NULL,  -- owns, controls, transacts_with, employed_by
    strength DECIMAL(3, 2) DEFAULT 1.0,  -- 0.0 to 1.0
    metadata JSONB,

    INDEX idx_rel_scenario (scenario_id),
    INDEX idx_rel_from_entity (from_entity_id),
    INDEX idx_rel_to_entity (to_entity_id),
    INDEX idx_rel_type (relationship_type)
);

COMMENT ON TABLE relationships IS 'Entity relationships for network analysis';
```

### 10. entity_reuse_log
**Purpose**: Track entity reuse across scenarios (for memory system)

```sql
CREATE TABLE entity_reuse_log (
    id SERIAL PRIMARY KEY,
    entity_id VARCHAR(100) REFERENCES entities(entity_id),
    scenario_id VARCHAR(100) REFERENCES scenarios(scenario_id),
    reuse_count INTEGER DEFAULT 1,
    role_in_scenario VARCHAR(100),
    reused_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_reuse_entity (entity_id),
    INDEX idx_reuse_scenario (scenario_id),
    INDEX idx_reuse_timestamp (reused_at)
);

COMMENT ON TABLE entity_reuse_log IS 'Tracks entity reuse across scenarios for memory system';
```

## Common Query Patterns

### 1. Get Complete Scenario (Visible Data Only)
```sql
SELECT
    s.scenario_id,
    s.typology,
    s.total_amount,
    json_agg(DISTINCT e.*) as entities,
    json_agg(DISTINCT a.*) as accounts,
    json_agg(DISTINCT t.*) as transactions
FROM scenarios s
LEFT JOIN entities e ON s.scenario_id = e.scenario_id
LEFT JOIN accounts a ON s.scenario_id = a.scenario_id
LEFT JOIN transactions t ON s.scenario_id = t.scenario_id
WHERE s.scenario_id = 'SCN_123'
GROUP BY s.scenario_id;
```

### 2. Get Scenario with Ground Truth
```sql
SELECT
    s.*,
    sm.plan_steps,
    sm.evasion_techniques,
    json_agg(DISTINCT jsonb_build_object(
        'entity', e,
        'ground_truth', egt
    )) as entities_with_labels
FROM scenarios s
LEFT JOIN scenario_metadata sm ON s.scenario_id = sm.scenario_id
LEFT JOIN entities e ON s.scenario_id = e.scenario_id
LEFT JOIN entity_ground_truth egt ON e.entity_id = egt.entity_id
WHERE s.scenario_id = 'SCN_123'
GROUP BY s.scenario_id, sm.plan_steps, sm.evasion_techniques;
```

### 3. Find Reusable Entities
```sql
SELECT
    e.*,
    egt.is_shell,
    egt.role_in_scenario,
    COUNT(erl.scenario_id) as scenario_count
FROM entities e
JOIN entity_ground_truth egt ON e.entity_id = egt.entity_id
LEFT JOIN entity_reuse_log erl ON e.entity_id = erl.entity_id
WHERE egt.is_shell = TRUE
GROUP BY e.entity_id, egt.is_shell, egt.role_in_scenario
HAVING COUNT(erl.scenario_id) <= 5
ORDER BY scenario_count ASC
LIMIT 10;
```

### 4. Detect Structuring Pattern
```sql
SELECT
    a.account_id,
    COUNT(*) as transaction_count,
    SUM(t.amount) as total_amount,
    AVG(t.amount) as avg_amount
FROM transactions t
JOIN accounts a ON t.from_account_id = a.account_id
WHERE t.amount BETWEEN 7000 AND 9999
    AND t.timestamp >= NOW() - INTERVAL '30 days'
GROUP BY a.account_id
HAVING COUNT(*) >= 3;
```

### 5. Entity Network Analysis
```sql
WITH RECURSIVE entity_network AS (
    -- Base case: starting entity
    SELECT
        from_entity_id,
        to_entity_id,
        relationship_type,
        1 as depth
    FROM relationships
    WHERE from_entity_id = 'ENT_123'

    UNION ALL

    -- Recursive case: connected entities
    SELECT
        r.from_entity_id,
        r.to_entity_id,
        r.relationship_type,
        en.depth + 1
    FROM relationships r
    JOIN entity_network en ON r.from_entity_id = en.to_entity_id
    WHERE en.depth < 3  -- Max 3 hops
)
SELECT DISTINCT * FROM entity_network;
```

## Indexes Strategy

### B-Tree Indexes (Default)
- Primary keys (automatic)
- Foreign keys for joins
- Frequently filtered columns (typology, country, timestamp)

### GIN Indexes for JSONB
```sql
CREATE INDEX idx_scenario_metadata_plan ON scenario_metadata USING GIN (plan_steps);
CREATE INDEX idx_entity_gt_indicators ON entity_ground_truth USING GIN (suspicious_indicators);
```

### Partial Indexes for Common Filters
```sql
CREATE INDEX idx_suspicious_entities ON entity_ground_truth(entity_id)
WHERE is_suspicious = TRUE;

CREATE INDEX idx_large_transactions ON transactions(transaction_id)
WHERE amount > 10000;
```

## Partitioning Strategy (Optional for Scale)

### Time-based Partitioning for Transactions
```sql
-- For very large datasets, partition transactions by month
CREATE TABLE transactions (
    ...
) PARTITION BY RANGE (timestamp);

CREATE TABLE transactions_2024_01 PARTITION OF transactions
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
```

## Performance Considerations

1. **Connection Pooling**: Use pgBouncer or application-level pooling (e.g., SQLAlchemy pool)
2. **Batch Inserts**: Use `INSERT INTO ... VALUES (...), (...), (...)` for multiple rows
3. **COPY for Bulk Load**: Use PostgreSQL COPY for large data imports
4. **VACUUM and ANALYZE**: Regular maintenance for query planner statistics
5. **Read Replicas**: Consider AWS RDS read replicas for analytics queries

## AWS RDS Specific Considerations

1. **Parameter Groups**: Tune `shared_buffers`, `work_mem`, `max_connections`
2. **Storage Type**: Use gp3 (General Purpose SSD) for cost-effective performance
3. **Backup Strategy**: Automated backups with 7-day retention
4. **Security Groups**: Restrict access to application servers only
5. **Encryption**: Enable encryption at rest and in transit
6. **Monitoring**: CloudWatch metrics for CPU, IOPS, connections

## Data Retention Policy

```sql
-- Archive old scenarios (optional)
CREATE TABLE scenarios_archive (LIKE scenarios INCLUDING ALL);

-- Move scenarios older than 1 year to archive
INSERT INTO scenarios_archive
SELECT * FROM scenarios
WHERE created_at < NOW() - INTERVAL '1 year';

DELETE FROM scenarios
WHERE created_at < NOW() - INTERVAL '1 year';
```

## Security Considerations

1. **Row-Level Security** (optional):
```sql
ALTER TABLE scenarios ENABLE ROW LEVEL SECURITY;

CREATE POLICY scenario_access_policy ON scenarios
    FOR SELECT
    USING (current_user = 'aml_app_user');
```

2. **Separate Roles for Visible vs Ground Truth**:
```sql
-- Read-only role for visible data (AML system)
CREATE ROLE aml_readonly;
GRANT SELECT ON entities, accounts, transactions, relationships TO aml_readonly;

-- Admin role with ground truth access (testing/evaluation)
CREATE ROLE aml_admin;
GRANT ALL ON ALL TABLES IN SCHEMA public TO aml_admin;
```

## Migration from File-Based Storage

```sql
-- Example: Bulk import from JSON files
COPY entities(entity_id, scenario_id, entity_type, name, country)
FROM '/path/to/entities.csv'
DELIMITER ',' CSV HEADER;
```

## Next Steps

1. Create DDL scripts (`schema.sql`)
2. Implement PostgreSQL loader interface (`postgres_loader.py`)
3. Create AWS RDS configuration (`postgres_config.yaml`)
4. Write integration tests
5. Implement data export utilities
